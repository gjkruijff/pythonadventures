\chapter{Till The Bitter End} 

\section{Introduction}

In the last chapter we saw how our code gradually became ever more complex. The code reflected a very strict order in which the player had to perform the actions ("the right way -- and the only way"). Any divergence from that resulted in us having to introduce more and more \texttt{if}-statements to cover those alternatives. 

Things became so complicated that we didn't even manage to get all the way to the end! So that is what we are going to do this chapter. We are going to refactor our code, (basically write a new program with bits from the old one), using two new constructions in Python: \textit{loops} and \textit{\function{s}}.

A \function\ is, simply put, a block of code that is outside of your "main" program, and that you can call to do something. Especially when you have to do that something many times, implementing it as a \function\ is very useful. You only have to implement it once, rather than repeat the code at every point where you need it. And, if you need to make a change, you only need to make it once (namely in the function) -- rather than at every point where you are using that code! 

We have used \function{s} in our code already as well: \texttt{print()} is one, \texttt{input()} another. The \texttt{print} function does something for us and that's it, whereas \texttt{input} does something too and then actually returns a result. 

What is more, looking at our code, there is plenty of repetition there. A good example is handling "help." In principle the player can ask for help anytime he wants. However, it would be very cumbersome to include all the help text in our code, every time we need to handle "help." So that is a good candidate for a function!

That brings us to \emph{loops}. 

\section{Loops}

A loop is a, literally, something that goes round. And round. And round. 

Sometimes you have a block of code that needs to be repeated like that. And rather than copying-and-pasting it a zillion times, so that you can execute that code that many times, Python offers different ways to formulate loops in your code. 

The kind of loop construction we use in this chapter mostly is the \whileloop\ loop. In a \whileloop\ loop we repeat a block of code, \textit{while} a certain condition holds: 

\begin{lstlisting}
while (...some condition...): 
      #do something  
\end{lstlisting}  

For example, for our adventure game, we want to continue going \textit{while} the player is still alive, and has not yet escaped the house: 

\begin{lstlisting}
while (isAlive == True and hasEscaped == False): 
      #do something  
\end{lstlisting}  

What is important to understand is that somewhere in the \texttt{\#do something} code block, these flags should change. At some point, the player should be able to escape, setting \texttt{hasEscaped} to \texttt{True}. At another point, the player may die an unfortunate death, setting \texttt{isAlive} to \texttt{False}. Why is that important? Because if the flags used in the condition would never ever change, then the loop would never end. You would end up with an \infiniteloop.

\begin{Exp}[Break statements]
Strictly speaking, you \emph{can} escape an infinite loop using a \breakloop\ statement within the loop.  

\begin{lstlisting}
while True: 
      # do something
      if (the right conditions): break  
\end{lstlisting}  

Sometimes you may have too many different conditions to check. Sometimes, it may be that "depending on the situation..." you want to have sometimes these, sometimes those conditions drive the decision whether to stop looping or not. When you need to check for such \emph{local} conditions, (rather than a few \emph{global} conditions like \texttt{isAlive == True}, then an infinite loop with suitable \breakloop{s} may be a better solution. \expend 
\end{Exp}  

Another useful loop construction is the \forloop-loop.  

\begin{lstlisting}
for <something> in <object>: 
      #do something  
\end{lstlisting}  

A \forloop-loop in Python cycles over \emph{something}'s from some \emph{object}. For example, imagine that we model the player inventory as a list of items \texttt{["sword", "library key", "handbag"]}. If the player then asks, "what do I have," you can use a \forloop\ to go through the list, and print one after other. 

\begin{lstlisting}
playerInventory = ["sword", "library key", "handbag"]
for item in playerInventory: 
      print(item, end=', ')
\end{lstlisting}  

\begin{Exe}
Type in the code above, and run it. Change the \texttt{end} bit into \texttt{end='--'} and run again. What if you completely remove the \texttt{end} part, (and the comma before it)? \expend  
\end{Exe}

\section{Restructuring Our Code} 

Now let us get started with our new-and-improved code. Best you create a new file, and save it under any name you like.

We begin with setting up our flags. Like before we use a small set of flags to track \emph{player inventory}, e.g. \texttt{hasMainKey}. And, to control our loop conditions, we also introduce a number of \emph{player status} flags.   

\begin{lstlisting}
# Python Adventure v2.0

# Initialize player inventory flags
hasMainKey = False
hasHandbag = False
hasSword = False
hasLibraryKey = False

# Initialize player status flags
isAlive = True
hasEscaped = False
isEntering = True
room = "Hallway"
\end{lstlisting}  

The flags \texttt{isAlive} and \texttt{hasEscaped} should be clear by now. We will come to \texttt{isEntering} and the \texttt{room} variable in a minute. 

Let us first set up the function for "help." As we said before, a player should be able to ask for help at any point in the adventure, but we don't want to have to repeat typing the help text every time. Instead, we can make a function call. 

We define a function using the \pythondef\ keyword. After that keyword comes a list of parameters, but as our function is not going to take any, we leave that aside for the moment. 

\begin{lstlisting}[firstnumber=last]
# Function to show the help text
def showHelp():
    print("Don't be scared. You can do a couple of things:")
    print("- 'go' in a compass direction, e.g. 'go south' ")
    print("- 'search' to 'search room', or look into an object")
    print("- 'attack' to attack a monster")
    print("- 'take' an object, e.g. 'take key' ")
\end{lstlisting}

Whenever the player now types in "help", all we have to do is call this function, and the help text is shown! 

\begin{verbatim}
if (command == "help") : showHelp()
\end{verbatim}

Time to start defining our \whileloop{s}. If you look at our adventure, there are essentially two loops. 

One is the main loop: continue the adventure while the player (character) is alive, and he has not escaped yet. 

The second is loop is \emph{when the player is in a room}. Think about it for a moment --  why a loop? Well, one way to approach that question is by looking at the trouble we ran into. It became difficult to allow the player to perform actions in any order. And it became difficult to then deal with moving to other rooms. 

Now imagine that whenever a player is in a room, you loop. In that loop, you handle whatever action the player wants to perform. You \emph{escape} that loop when the player moves to another room -- where a similar loop then begins again. Get it? Let us look at the basic structure of the code, and then all will become clear. 

\begin{lstlisting}[firstnumber=last]
# Main loop - as long as the player is alive, and has not escaped, continue
while (isAlive == True and hasEscaped == False):

    if (room == "ROOMNAME"):
        if (isEntering):
            # print the room description
            isEntering = False
        # Loop within the room, as long as player is not leaving, and alive    
        while (isAlive == True and isEntering == False):
            command = input("> ")
            if (command == "go DIRECTION"):
                # change the room, set flag that player is entering
                room = "ROOMNAME"
                isEntering = True
            if (command == "look around" or "search room"):
                # print description

            if (command == "attack"):
                # if there is something to attack, handle attack
                # otherwise provide a witty statement
            if (command == "take OBJECT"):
                # check whether the object can be taken; if so take
            if (command == "help") : showHelp()
\end{lstlisting}

Line 22 sets up the main \whileloop-loop. We saw this one before: run the adventure as long as the player is alive, and hasn't escaped yet. Next, remember that earlier on (in line 13 -- how ominous!) we set up the \texttt{room} variable. We initialized it with the value \texttt{"Hallway"} as this is the room the player starts in. 

Within the main \whileloop-loop we then check which room the player is currently in. Assume for the moment that line 24 reads \texttt{room == "Hallway"} so that we enter that block. Then the first check we make (line 25) is whether the player is \emph{entering} that room. Why? Well, only upon entering a room are we going to display the room description. As soon as we have done that, we set the flag \texttt{isEntering} to \texttt{False}. The player is now in the room. 

Next comes the next loop, within the room itself (line 29). As long as the player is not leaving, and is still alive, we let him do whatever he wants (sort of). At the beginning of the loop, we get the next player command (line 30), and then we have several \texttt{if}-blocks to handle the various commands. 

If you look at the \texttt{if}-block for "go", you see how we escape from the room loop -- by going to another room! Depending on the direction and where the player decides to go, we set the \texttt{room} variable to the appropriate name (e.g. "go north" from the Hallway sets \texttt{room="Parlour"}) \emph{and} we set still true at this point), and then the new value for \texttt{room} gets us into the code block for a different room. Where the next room-specific \whileloop-loop then starts.      





 
 













   